# Web3 Constitutional AI - Democratic Evolution Platform

## 🎯 **MASSIVE CONVERSATIONAL AI TRAINING SYSTEM** (September 2025)

**BREAKTHROUGH**: We've evolved from character-level pattern matching to **genuine conversational AI** using **25MB of training data** from HuggingFace datasets. Agents now train on **word-level semantic understanding** with **101K+ word vocabulary** and **311K training sequences**.

### 🚀 **Training Scale Achieved:**
- **25,072,370 characters** (25.07 MB) of diverse text data
- **4,675,405 total words** for pattern learning
- **101,334 unique words** vocabulary
- **311,693 training sequences** (15-word context windows)
- **Word-level processing** for semantic understanding
- **Conversational focus** with dialogue patterns prioritized

### 🧠 **AI Capabilities:**
- **Genuine conversation** (not just pattern matching)
- **Semantic understanding** of word relationships
- **Context-aware responses** with 15-word memory
- **Vocabulary diversity** across multiple domains
- **Constitutional personality** influencing language style

---

## System Overview

A **revolutionary platform** for evolving self-governing AI agents using constitutional diploid genomes, neural evolution (NEAT), and deep governance systems. Agents can reach **100M+ parameters** (50K-200K nodes, 500K-10M connections) and develop genuine intelligence in language and reasoning through **democratically-controlled evolutionary processes** and constitutional self-governance.

### 🏛️ **Revolutionary Deep Governance**
The world's first AI system where **agents democratically vote on their own evolutionary parameters**. Through constitutional governance, AI populations control mutation rates, selection pressure, and evolutionary algorithms - creating truly self-governing artificial species.

---

## 🚀 Quick Start (Updated September 2025)

### **Option 1: Indefinite Evolutionary Cycle (Recommended)**
```bash
# Run continuous evolution with governance (Ctrl+C to stop)
python evolutionary_cycle.py
```
- ✅ **Governance enabled** by default
- ✅ **Continuous evolution** cycles with **25MB conversational training**
- ✅ **Democratic voting** every 3 cycles
- ✅ **Agent breeding** and selection
- ✅ **Training escalation** over time
- ✅ **Word-level language evolution**

### **Option 2: Parallel Evolution (Fast Training)**
```bash
# Maximum CPU utilization with dynamic resource allocation
python parallel_evolution.py --governance
```
- ✅ **Dynamic hardware detection** (adapts to your CPU/RAM)
- ✅ **Parallel processing** (all cores utilized)
- ✅ **Staggered I/O** to prevent bottlenecks
- ✅ **Governance voting** on training parameters

### **Option 3: Standard Parallel Evolution**
```bash
python parallel_evolution.py
```
- ✅ **Same dynamic features** as above
- ✅ **No governance** (faster, less democratic)

---

## Core Components

### Constitutional AI
- **Diploid Genome System**: Agents have maternal and paternal alleles following Mendelian genetics.
- **Stabilization Types**: Six behaviors (Static, Progressive, Oscillatory, Degenerative, Chaotic, Multi-attractor) define agent personality and trait evolution.
- **Trait Resolution**: Uses recursive fixed-point processes for emergent trait computation.
- **AI Traits**: **39 comprehensive traits** covering cognitive, learning, behavioral, performance, social, and **governance capabilities**. Includes Phase 4 governance traits: Leadership, EthicalReasoning, ConflictResolution, CulturalIntelligence, Negotiation, GoalOrientation, Autonomy, Humor, and Creativity.
- **Identity System**: Cryptographically verified agent authenticity using SHA-256 hashing.

### Language Corpus System
- **Data Sources**: Integrates HuggingFace datasets (WikiText-103, OpenWebText, BookCorpus, C4, Wikipedia).
- **Corpus Size**: **25,072,370 characters (25.07 MB)** production-scale training data.
- **Word-Level Processing**: **101,334 vocabulary** with semantic understanding.
- **Training Sequences**: **311,693 sequences** with 15-word context windows.
- **Conversational Focus**: Dialogue patterns prioritized for genuine conversation.
- **Caching**: Downloads data once, stores locally for reuse.
- **Fallback**: Automatically switches between data sources if one fails.

### Dynamic Resource Optimization
- **Hardware Detection**: Automatically detects CPU cores and RAM
- **Adaptive Scaling**: Adjusts agent count and generations based on hardware
- **I/O Optimization**: Staggered process starts prevent disk/network bottlenecks
- **Memory Awareness**: Scales training intensity based on available RAM

### CPU-Optimized Training
- **NEAT-Optimized**: CPU training specifically designed for NeuroEvolution of Augmenting Topologies.
- **Flexible Architecture**: Each neural network can have different topologies (not possible with GPU batching).
- **Sequential Processing**: Evolutionary algorithms work best with CPU's flexible processing.
- **Memory Efficient**: No GPU memory transfer overhead for diverse network structures.

### Logic Test Battery
- **Test Levels**: Six levels of increasing difficulty:
  - Level 1: XOR (4 patterns)
  - Level 2: AND/OR Gates (8 patterns)
  - Level 3: NAND Gate (4 patterns)
  - Level 4: 3-Input XOR (8 patterns)
  - Level 5: Majority Gate (8 patterns)
  - Level 6: 4-Input Parity (16 patterns)
- **Purpose**: Benchmarks agent learning, validates learning vs. memorization, and analyzes trait impact on performance.
- **Processing**: CPU-optimized sequential processing for diverse network topologies.

### Constitutional Governance System
- **Deep Governance**: Agents vote on evolutionary rules (mutation rates, selection pressure, parameter mappings).
- **Trait-Based Voting**: Constitutional traits determine voting weight and behavior.
- **Democratic Evolution**: Populations control their own evolutionary algorithms.
- **Governance Proposals**: Five types - breeding rules, population size, system parameters, evolutionary rules, NEAT mappings.
- **Agent Councils**: Specialized councils (technical, ethical, social, general) for domain expertise.
- **Decision Execution**: Real implementation of approved proposals into evolutionary parameters.

### Mathematical Properties
- **Fixed Points**: Trait convergence guaranteed via Kleene fixed points.
- **Monotone Mapping**: Higher trait values do not decrease neural parameters.
- **Reproduction**: Deterministic, producing identical agents for identical inputs.
- **Hashing**: SHA-256 for agent authenticity verification.
- **Governance Thresholds**: High majority requirements (67-75%) for deep evolutionary changes.

### Visual Identity
- **Color Generation**: HSV/RGB colors computed from constitutional traits.
- **NFT Artwork**: Unique visual signatures for each agent.
- **Descriptions**: Human-readable color-based personality indicators.

---

## System Architecture

```
Constitutional AI → Governance System → NEAT Evolution → Blockchain NFTs
- Diploid Genomes    - Democratic Voting    - Neural Networks     - ERC721 Tokens
- 39 AI Traits       - Evolutionary Rules   - Trait-Configured    - Visual Identity
- Trait Resolution   - Agent Councils       - Learning Capable    - Provenance Chain
- Identity Creation  - Decision Execution   - Problem Solving     - Immutable Storage
- Dynamic Scaling    - Hardware Detection   - Parallel Training   - Metadata Storage
```

### Directory Structure

```
web3-neat-nft/
├── constitutional_ai/
│   ├── genome.py                  # Diploid genome with stabilization
│   ├── traits.py                  # 39 comprehensive AI traits
│   ├── emergent_constitution.py   # Fixed-point trait resolution
│   ├── breeder.py                 # Mendelian breeding
│   ├── identity.py                # Agent identity creation
│   ├── governance.py              # Deep governance system
│   ├── neat_mapper.py             # Governance-influenced trait-to-NEAT mapping
│   ├── neat_integration.py        # Governance-aware NEAT evolution
│   ├── color_mapping_simple.py    # Visual DNA generation
│   ├── persistence.py             # Agent save/load
│   ├── corpus_loader.py           # Language corpus integration
│   └── training/                  # CPU-optimized training modules
│       ├── base_capability.py     # Capability framework
│       ├── language_evolution.py  # Language learning
│       └── coding_evolution.py    # Coding skill development
├── evolutionary_cycle.py          # Indefinite evolution with governance
├── parallel_evolution.py          # Dynamic parallel training with governance
├── agents/                        # Trained agent storage
├── logic_tests.py                 # Logic test battery
├── agent_browser.py               # CLI for agent management
├── test_deep_governance.py        # Deep governance validation
├── test_39_trait_system.py        # Complete trait system validation
├── quick_test.py                  # System verification
├── contracts/                     # NFT smart contracts
├── web3/                         # Blockchain integration
├── tests/                        # Test suite
└── constitutional_neat/          # Legacy directory
```

---

---

## System Architecture

```
Constitutional AI → Governance System → NEAT Evolution → Blockchain NFTs
- Diploid Genomes    - Democratic Voting    - Neural Networks     - ERC721 Tokens
- 39 AI Traits       - Evolutionary Rules   - Trait-Configured    - Visual Identity
- Trait Resolution   - Agent Councils       - Learning Capable    - Provenance Chain
- Identity Creation  - Decision Execution   - Problem Solving     - Immutable Storage
```

### Directory Structure

```
web3-neat-nft/
├── constitutional_ai/
│   ├── genome.py                  # Diploid genome with stabilization
│   ├── traits.py                  # 39 comprehensive AI traits
│   ├── emergent_constitution.py   # Fixed-point trait resolution
│   ├── breeder.py                 # Mendelian breeding
│   ├── identity.py                # Agent identity creation
│   ├── governance.py              # Deep governance system
│   ├── neat_mapper.py             # Governance-influenced trait-to-NEAT mapping
│   ├── neat_integration.py        # Governance-aware NEAT evolution
│   ├── color_mapping_simple.py    # Visual DNA generation
│   ├── persistence.py             # Agent save/load
│   ├── corpus_loader.py           # Language corpus integration
│   └── training/                  # CPU-optimized training modules
│       ├── base_capability.py     # Capability framework
│       ├── language_evolution.py  # Language learning
│       └── coding_evolution.py    # Coding skill development
├── agents/                        # Trained agent storage
├── logic_tests.py                 # Logic test battery
├── agent_browser.py               # CLI for agent management
├── test_deep_governance.py        # Deep governance validation
├── test_39_trait_system.py        # Complete trait system validation
├── quick_test.py                  # System verification
├── contracts/                     # NFT smart contracts
├── web3/                         # Blockchain integration
├── tests/                         # Test suite
└── constitutional_neat/          # Legacy directory
```

---

## Installation

### Prerequisites
- Python 3.8+
- Node.js 16+
- Web3 stack (Hardhat, Ethers.js)
- `neat-python` library
- CPU-optimized for NEAT evolution

### Steps

```bash
git clone https://github.com/yourusername/web3-neat-nft.git
cd web3-neat-nft
pip install -r requirements.txt
npm install
```

---

## Usage Guide

### 🏛️ Constitutional Democracy Setup

```bash
# 1. Run indefinite evolutionary cycle (recommended)
python evolutionary_cycle.py

# 2. Or run parallel evolution with governance
python parallel_evolution.py --governance

# 3. Verify 39-trait system
python test_39_trait_system.py

# 4. Test deep governance
python test_deep_governance.py

# 5. Check population status
python top_agents.py
```

### 🧬 Evolution Commands

```bash
# Continuous evolution with governance (Ctrl+C to stop)
python evolutionary_cycle.py

# Parallel evolution with dynamic resource allocation
python parallel_evolution.py --governance

# Fast parallel evolution (no governance)
python parallel_evolution.py
```

### 🗳️ Interactive Governance Session

```python
# Interactive governance session
from constitutional_ai.governance import create_governance_manager_from_agent_list
from constitutional_ai.persistence import list_all_agents

# Load agents for governance
agent_ids = list_all_agents()
governance = create_governance_manager_from_agent_list(agent_ids[:6])

# Propose evolutionary rule change
proposal = governance.propose_evolutionary_rule_change(
    rule_name="innovation_boost",
    target_parameter="weight_mutation_rate",
    modification={"type": "multiplier", "value": 2.0},
    description="Double mutation rates for accelerated evolution"
)

# Democratic vote
result = governance.conduct_vote(proposal)
print(f"Result: {'PASSED' if result.passed else 'FAILED'}")
```

---

## Usage

### Agent Browser CLI

```bash
# Verify system
python quick_test.py

# List agents with traits
python agent_browser.py list

# Show agent details
python agent_browser.py show 9488b0a1

# Train agent
python agent_browser.py train 9488b0a1 language --generations 5
python agent_browser.py train 9488b0a1 coding --generations 3

# Test agent
python agent_browser.py test 9488b0a1 "Hello world"
python agent_browser.py test-coding 9488b0a1 "def hello"

# Breed agents
python agent_browser.py breed 9488b0a1 725af723 --count 2 --generations 3

# Thoroughbred breeding
python agent_browser.py breed 2212c880 31fdce95 --count 5 --generations 8

# Tournament breeding
python agent_browser.py progressive-breed 2212c880 31fdce95 --rounds 3 --offspring-per-round 4

# Chat with agent
python agent_browser.py chat 9488b0a1

# Run logic tests
python logic_tests.py --all

# Show top agents
python top_agents.py
```

### Create and Train Agent

```python
from constitutional_ai import create_random_genome, COMPLETE_TRAIT_DEFINITIONS, create_agent_identity
from constitutional_ai.training.language_evolution import train_agent_language_capability
from constitutional_ai.persistence import save_training_result

# Create genome
genome = create_random_genome(COMPLETE_TRAIT_DEFINITIONS, seed=42)

# Create identity
identity = create_agent_identity(genome, seed_closure=123)

# Train in language
result = train_agent_language_capability(identity, generations=5)

# Save agent
result['identity_bundle'] = identity
agent_id = save_training_result(result, 'language')
```

---

## System Status (September 2025)

- **Evolution Scripts**: `evolutionary_cycle.py` and `parallel_evolution.py` fully functional
- **Governance System**: Deep governance with democratic voting implemented
- **Dynamic Scaling**: Hardware-adaptive resource allocation working
- **Agent Population**: Growing through continuous evolution cycles
- **Traits**: Complete 39-trait system with governance capabilities
- **Performance**: Optimized for maximum CPU utilization

---

## Multi-Capability Training

### Language Training

```python
from constitutional_ai.corpus_loader import get_language_corpus
from constitutional_ai.training.language_evolution import train_agent_language_capability
from constitutional_ai.persistence import load_agent

# Load 1MB Wikipedia text
corpus = get_language_corpus(1_000_000)

# Train agent
result = train_agent_language_capability(agent_identity, generations=10)

# Test agent
record = load_agent(result['agent_id'])
```

### Coding Training

```python
from constitutional_ai.training.coding_evolution import train_agent_coding_capability

# Train agent
result = train_agent_coding_capability(agent_identity, generations=8)
```

### Cross-Capability Breeding

```python
from constitutional_ai.persistence import load_agent

# Load specialized agents
language_expert = load_agent("9488b0a1")
coding_expert = load_agent("725af723")

# Breed
# Command: python agent_browser.py breed 9488b0a1 725af723
```

---

## Logic Test Results (Example)

```
Agent 31fdce95 (High LearningRate):
├── Level 1 (XOR): PASS (4/4)
├── Level 2 (AND/OR): PASS (8/8)
├── Level 3 (NAND): PASS (4/4)
├── Level 4 (3-XOR): PASS (8/8)

Agent 53bac160 (High Stability):
├── Level 1 (XOR): PASS (4/4)
├── Level 2 (AND/OR): PASS (8/8)
├── Level 3 (NAND): FAIL (2/4)
```

---

## NEAT Integration

- **Population Size**: 50–2000 agents, based on traits.
- **Mutation Rates**: Controlled by Innovation Drive and Risk Tolerance.
- **Network Architecture**: Derived from cognitive/performance traits.
- **Learning Parameters**: Set by Learning Rate and Meta-Learning.
- **Selection Pressure**: Influenced by Stability and Social traits.

---

## Visual DNA

```python
from constitutional_ai import traits_to_hsv_simple, traits_to_simple_color, get_simple_color_description

traits = identity.constitution_result.constitution
hsv_color = traits_to_hsv_simple(traits)
hex_color = traits_to_simple_color(traits)  # e.g., "#A040F4"
description = get_simple_color_description(hex_color)  # e.g., "Blue-dominant"
```

---

## Testing

### Test Commands

```bash
# Constitutional system
python -c "from constitutional_ai import *; genome = create_random_genome(COMPLETE_TRAIT_DEFINITIONS, seed=42); identity = create_agent_identity(genome); print(f'Constitutional system: {identity.id_hash[:12]}')"

# Breeding system
python -c "from constitutional_ai import ConstitutionalBreeder, create_random_genome, COMPLETE_TRAIT_DEFINITIONS; breeder = ConstitutionalBreeder(); p1 = create_random_genome(COMPLETE_TRAIT_DEFINITIONS, seed=1); p2 = create_random_genome(COMPLETE_TRAIT_DEFINITIONS, seed=2); result = breeder.breed_agents(p1, p2, seed=3); print(f'Breeding system: {result.offspring.compute_genome_hash()[:12]}')"

# NEAT integration
python -c "from constitutional_ai.neat_integration import evolve_constitutional_agent; from constitutional_ai import create_random_genome, COMPLETE_TRAIT_DEFINITIONS; import neat; def simple_fitness(genomes, config): [setattr(g, 'fitness', 1.0) for _, g in genomes]; genome = create_random_genome(COMPLETE_TRAIT_DEFINITIONS, seed=42); result = evolve_constitutional_agent(genome, simple_fitness, generations=2); print(f'NEAT integration: {result['final_fitness']}')"
```

---

## Hardware Optimization Features

### Dynamic Resource Allocation
- **CPU Detection**: Automatically uses all available cores minus 1
- **Memory Scaling**: Adjusts training intensity based on RAM
- **Adaptive Agent Count**: Scales number of agents based on hardware
- **Smart Generation Scaling**: Balances speed vs. quality

### I/O Optimization
- **Staggered Starts**: Prevents all processes downloading simultaneously
- **Dataset Caching**: Reuses downloaded corpora for faster subsequent runs
- **Fallback Sources**: Automatically switches data sources if one fails

### Performance Monitoring
```python
# Monitor system resources during evolution
import psutil
cpu = psutil.cpu_percent()
ram = psutil.virtual_memory().percent
print(f"CPU: {cpu}%, RAM: {ram}%")
```

---

## Performance Metrics

- **Capabilities**: Language and coding skill evolution, cross-generation breeding, agent persistence, population scaling (50–2000 agents), trait diversity, identity verification, visual DNA.
- **Fitness Improvement**: Offspring fitness from 0.037 to 0.043.
- **Scalability**:
  - Generation time: ~2 seconds for 1500+ agents.
  - Trait resolution: Converges in <50 iterations.
  - Memory: Efficient genome storage.
- **Neural Evolution**: Unlimited complexity via NEAT-python.

---

## Deployment

```bash
# Compile contracts
npm run compile

# Deploy to testnet
npm run deploy

# Verify contract
npx hardhat verify --network goerli DEPLOYED_CONTRACT_ADDRESS
```

---

## Applications

- AI agent NFTs
- Evolving game NPCs
- AI research tools
- Educational platform for genetics/AI/blockchain
- Art generation with unique visuals

---

## License

MIT License (see LICENSE file).

---

## Resources

- NEAT Algorithm: [http://nn.cs.utexas.edu/downloads/papers/stanley.ec02.pdf](http://nn.cs.utexas.edu/downloads/papers/stanley.ec02.pdf)
- Constitutional AI: [docs/](docs/)
- Web3 Integration: [contracts/README.md](contracts/README.md)
- Governance System: Deep democratic AI evolution
- Hardware Optimization: Dynamic resource allocation

---
